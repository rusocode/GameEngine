-VAO y VBO
Los objetos de matriz de vertices, vertex array objects (VAO) en ingles, son la forma moderna de almacenar y representar modelos en OpenGL 
reemplazando la lista de visualizacion antigua y el modo inmediato. Un VAO es un objeto para alamcenar datos sobre un modelo 3D. El VAO
tiene un monton de espacios para almacenar esos datos y estos espacios se conocen como lista de atributos. En uno de esos espacios puede
almacenar todas las posiciones de los vertices, en otra puede almacenar todos los colores de todos los vertices o el vector normal en cada
vertice o las coordenadas de textura en cada vertice. Estos conjuntos de datos se almacenan en las listas de atributos como objetos de buffer
de vertices, vertex buffer objects (VBO) en ingles. Un VBO es solo datos, puede verlo como un conjuto de numeros y esos datos pueden ser
cualquier cosa, como posiciones, colores, normales o lo que sea. Cada VBO se puede colocar en una lista de atributos separada en el VAO.
Asi es como se almacenan los datos, pero ¿como accedemos a estos datos cuando los necesitamos? Cada VAO tiene una ID unica, por lo que
cuando el VAO se almacena en la memoria podemos acceder a el en cualquier momento usando su ID. ¿Pero como representamos exactamente un
modelo 3D como una carga de datos que podriamos almacenar en un VAO? Cada modelo 3D con el que vamos a tratar esta hecho de varios
triangulos y cada uno de estos triangulos tiene tres vertices, tres puntos en el espacio tridimensional. Por lo que cada vertice tiene 
una coordenada 3D, una X, Y y una Z, y si tomamos las coordenadas de cada uno de los tres vertices del triangulo y luego las coordenadas
de los otros triangulos en el modelo, tendremos una lista datos que representa todas las posiciones de los vertices del modelo. Este tipo
de datos son los que se pueden poner en el VBO y almacenar en una lista de atributos de un VAO. Un ejemplo simple, seria renderizar el
modelo 3D mas simple: un rectangulo que esta hecho de solo dos triangulos y vamos a tomar los datos de posicion de los vertices de esos
triangulos creando un VBO, almacenando los datos en el VBO, creando un VAO, almacenando los datos del VBO en una de las listas de atributos
del VAO y luego usaremos el ID del VAO para decirle a OpenGL que represente el rectangulo en pantalla.

-Sistema de coordenadas de OpenGL
En el sistema de coordenadas de OpenGL, el origen es el centro (0,0), (0,1) es el borde superior, (0,-1) es el borde inferior, (-1, 0)
corresponde al borde izquierdo y (1,0) al borde derecho. Debido a que estamos trabajando en 3D, el eje z apunta hacia usted fuera de
la pantalla.

-Index buffers
Supongamos que tenemos 4 vertices para representar un rectangulo, en donde V0 (primer vertice) esta ubicando en (-0.5, 0.5, 0),
V1 en (-0.5, -0.5, 0), V2 en (0.5, -0.5, 0) y V3 en (0.5, 0.5, 0). ¿Que orden tenemos para darle estas coordenadas a OpenGL? Como bien sabemos,
todo lo que dibujamos tiene que estar en triangulos y necesitamos informarle a OpenGL sobre los dos triangulos que forman los 4 vertices mencionados.
OpenGL siempre necesita que especifiquemos estos vertices en el sentido contrario a las agujas del reloj. Asi que empecemos con el triangulo superior
izquierdo comenzando con el vertice V0. Ahora debe girar en sentido antihorario alrededor del triangulo para especificar los otros vertices, de modo
que el siguiente sea V1 y finalmente V3, y este es el triangulo superior izquierdo. Asi que para el otro triangulo vamos a iniciar desde V3 hasta V1
y finalizar en V2. Ahora ambos triangulos estan representados en esta lista de vertices: (-0.5,0.5,0,-0.5,-0.5,0,0.5,0.5,0,0.5,0.5,0,-0.5,-0.5,0,0.5,-0.5,0).
Esta lista es la que podemos cargar y renderizar en nuestro juego. Pero hay un problema con este metodo de renderizado.
Si repasamos como especificamos los vertices, teniamos V0, V1 y V3 para el primer triangulo y luego V3, V1 y V2 para el segundo triangulo, dejando la 
lista de esta manera: (V0,V1,V3,V3,V1,V2). Como puede ver, los datos para V3 se especifican dos veces al igual que V1. Estamos enviando datos a OpenGL
para 6 vertices cuando en realidad solo hay cuatro vertices diferentes en el rectangulo. Idealmente, lo que queremos hacer es enviar a OpenGL una lista
de los cuatro vertices diferentes en el modelo, pero luego OpenGL no tendria forma de saber como conectarlos. Para que podamos decirle a OpenGL como 
conectarlos usamos otro VBO, otro conjunto de datos llamado Index Buffer para ayudar a definir el modelo y estos datos le dicen a OpenGL el orden en el
que deben conectar los vertices para hacer triangulos que se puedan representar. Asi que creamos el buffer de indices para nuestro rectangulo y definimos
los dos triangulos exactamente de la misma manera que antes, asi que comenzamos en el vertice V0 que lo representamos con un 0 en el Index Buffer, luego 
pasamos a V1 que esta en la posicion 1 en la lista de vertices, y para terminar el primer triangulo lo conectamos a V3 que esta en la posicion 3 en la lista.
Lo mismo se aplica para el segundo triangulo, quedando la lista de la siguiente forma: (0,1,3,3,1,2). Esta vez estamos usando 4 vertices en lugar de 6, pero
ahora necesitamos un conjuto adicional de datos, el Index Buffer que contiene 6 ints, por lo que te preguntaras si vale la pena. Cada vertice son 3 floats (x,y,z),
el primer metodo uso 6 vertices, dando un total de 18 floats. El segundo metodo necesita solo 4 vertices que son 12 floats, pero tambien necesito la ayuda de
6 ints. Esto parece inutil, los dos metodos parecen usar la misma cantidad de datos para representar el rectangulo. Pero este rectangulo es muy simple, cada vertice
solo se describe mediante una posicion de 3 floats y esto en la vida real es poco realista. Cuando se implemente la iluminacion, cada vertice necesitara un normal
asociado a el, que son otros 3 floats, y cada vertice tambien necesitara una coordenada de textura si queremos texturizar nuestros modelos, lo cual, son otros
2 floats. Ademas, en total cada vertice tendra al menos 8 floats de datos asociados y en sistemas de renderizado mas complejos podria tener aun mas. Entonces,
esto nos dara un total de: 3 position + 3 normal + 2 tex coords = 8 floats * 6 vertices = 48 floats. Mientras que en el segundo metodo solo necesitariamos
32 floats: 8 floats * los 4 vertices + los 6 ints. Por lo que ahora puedes comenzar a ver una diferencia entre los dos metodos. En terminos de bytes, suponiendo
que un float y un int son de 4 bytes cada uno, el primer metodo representa un rectangulo de 192 bytes, mientras que el segundo puede representar solo 152 byte, es decir
un 20% menos de datos para representar exactamente el mismo rectangulo y esto es solo para un simple rectangulo, donde solo dos de los vertices se compartieron entre
triangulos. En modelos mas grandes y complejos, los vertices podrian compartirse entre tres, cuatro, cinco o mas triangulos, por lo que las cantidades de datos duplicados
que enviarias usando el primer metodo seria una locura. El segundo metodo generalmente podra representar un modelo con 30, 40 o 50% menos de datos!


-Funcionamiento de la camara en OpenGL
En OpenGL no existe una camara que muestre los objetos en pantalla, en su lugar se simula el efecto de la camara moviendo los objetos
en el eje de coordenadas de OpenGL. El centro de la pantalla es [0,0] y no se puede cambiar. Para simular el efecto de movimiento de la 
camara, se mueven todos los objetos en la direccion opusta. Por ejemplo, si muevo todo el mundo hacia la derecha hara que parezca que la
camara se esta moviendo hacia la izquierda. Asi que para mover todos los objetos se usa una matriz de transformacion que representa una 
transformacion. Eso es exactamente lo opuesto a la transformacion de la camara. Esta matriz se conoce como View Matrix y se actualizara cada
vez que nuestra camara se mueva.

-Normales
Un vector normal es un vector de direccion que apunta en la direccion exacta a la que mira una superficie. Cada punto de una superficie
tiene un vector normal y siempre apunta directamente hacia afuera. En otra palabras, es perpendicular a la cara del objeto. Basicamente la 
normal de una superficie nos dice en que direccion mira y eso es exactamente lo que necesitamos. Teniendo la normal en cada vertice y la
posicion de la fuente de luz, podemos calcular que tan brillante debe ser cada punto del objeto. Para hacer esto, para un punto dado del
objeto, primero vamos a encontrar el vector desde ese punto del objeto hasta la fuente de luz. Ahora cada punto en la superficie del objeto
tendra dos vectores, un vector que apunta hacia la fuente de luz (toLightVector) y un vector normal que muestra la direccion en la que mira 
la superficie (surfaceNormal). Mientras mas mira una superficie hacia la luz, mas cerca estan estos dos vectores, por lo que podemos determinar
que tan brillante debe ser un punto del objeto dependiendo de cuanto apunten los dos vectores en ese punto en la misma direccion. Si los dos 
vectores apuntan en la misma direccion, el punto sera completamente brillante. En caso contrario, el punto sera menos brillante porque los dos 
vectores apuntan en direcciones diferentes. Para medir que tan cerca estan dos vectores de apuntar en la misma direccion se usa el Dot 
Product (producto escalar) de dos vectores. El producto escalar de dos vectores unitarios que apuntan exacatamente en la misma direccion es 1 
y el producto escalar de dos vectores perpendiculares que apuntan en direcciones totalmente diferentes es 0, y todo lo demas esta en algun 
punto intermedio, por lo que esto nos da una representacion perfecta de que tan similares son dos vectores y, por lo tanto, una representacion 
perfecta de que tan brillante debe ser un cierto punto en el objeto.
En el producto escalar, solo las multiplicaciones en la misma direccion cuentan.
https://betterexplained.com/articles/vector-calculus-understanding-the-dot-product/

-Iluminacion especular
La iluminacion especular es la luz reflejada en objetos brillantes. La luz reflejada corresponde al rayo de luz entrante. La cantidad de luz
que se refleja depende de la reflectividad de la superficie. Esta cantidad se representa en el codigo con el atributo reflectivity. Si el objeto
tiene una reflectividad alta, entonces la luz reflejada sera mas fuerte y si tiene una reflectividad baja, entonces la luz reflejada sera mucho
mas debil. El brillo de este punto tambien depende de un ultimo factor y es la posicion de la camara. Si la camara apunta directo a la luz
reflejada, entonces el punto tendria un brillo especular muy alto porque la luz reflejada va directamente a la camara. Si la camara esta colocada
en un lugar opuesto, entonces no entra la luz reflejada, y por lo tanto no tendria ninguna iluminacion especular. Finalmente, si la camara
estuviera apuntando cerca de la luz reflejada, probablemente recibiria algo de luz y, por lo tanto, el punto tendria un poco de iluminacion
especular, pero depende del material, por lo que tendremos otro atributo llamado shine damping, que determina que tan cerca debe estar la 
camara de la luz reflejada para ver cualquier cambio en el brillo de la superficie de los objetos.
Para calcular la iluminacion especular a partir de reflectivity y shine damping necesitamos la direccion de luz entrante, que es el vector
desde la fuente de luz hasta el punto del objeto. Luego reflejaremos la luz entrante para obtener la direccion de la luz reflejada y tambien
necesitamos un vector mas que es un vector desde el punto del objeto hasta la camara. El punto tendra la iluminacion especular mas brillante
cuando el vector de la luz reflejada y el vector que apunta desde el objeto a la camara esten en la misma direccion. Para descubrir que tan
cerca estan estos dos vectores de apuntar en la misma direccion, se utiliza el producto escalar para determinar que tan brillante (brightness) 
debe ser la luz especular en ese punto de la superficie. Podemos usar el atributo shine damping del brillo del material para amortiguar el
brillo y luego multiplicarlo por la reflectividad de la superficie antes de agregarlo a la iluminacion difusa para obtener el resultado
final.
Ahora tenemos el vector de direccion de la luz, el vector que apunta a la camara y la superficie de la normal, asi que todo lo que necesitamos
ahora es el vector de luz reflejada. GLSL tiene una funcion de reflexion para hacer esto, reflect. Esta funcion toma el vector de la luz entrante
y la normal de la superficie con la que desea reflejar la luz, y devuelve la direccion de la luz reflejada. Una vez calculada la direccion de
la luz reflejada (reflectedLightDirection) y el vector normalizado que apunta del objeto a la camara (unitVectorToCamera), podemos hacer el
calculo del producto escalar para ver cuanta luz reflejada ingresa a la camara.

