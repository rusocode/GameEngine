#version 400 core

in vec4 clipSpace;
in vec2 textureCoords;

out vec4 out_Color;

uniform sampler2D reflectionTexture, refractionTexture, dudvMap;

// Offset para donde tomamos muestras del mapa dudv que cambia con el tiempo, lo que hara que el agua parezca que se esta moviendo
uniform float moveFactor;

// Indica la instensidad de la distorsion
const float waveStrength = 0.02;

void main(void) {

    /* Realiza la division de perspectiva para normalizar el espacio del dispositivo. Para muestrear una textura tenemos
     * que dar las coordenadas del espacio de pantalla de cualquier punto dado del cuadrilatero de agua en este sistema
     * de coordenadas para poder usar esas mismas coordenadas para muestrear las texturas. Esto se hace dividiendo por
     * 2 y sumando 0.5, esto nos dara las coordenadas del espacio de la pantalla. */
    vec2 ndc = (clipSpace.xy / clipSpace.w) / 2.0 + 0.5;
    // Invierte la coordenada [y] debido a que es una reflexion
    vec2 reflectTexCoords = vec2(ndc.x, -ndc.y);
    // Las coordenadas de la texturan de refraccion son iguales a las coordenadas normalizadas del dispositivo (ndc)
    vec2 refractTexCoords = vec2(ndc.x, ndc.y);

    // Muestrea el mapa dudv para obtener la distorsion obteniendo solo los valores verde y rojo, y luego se hace la conversion para obtener un rango de valores entre -1 y 1
    vec2 distortion1 = (texture(dudvMap, vec2(textureCoords.x + moveFactor, textureCoords.y)).rg * 2.0 - 1.0) * waveStrength;
    // Mueva la distorsion en una direccion diferente
    vec2 distortion2 = (texture(dudvMap, vec2(-textureCoords.x + moveFactor, textureCoords.y + moveFactor)).rg * 2.0 - 1.0) * waveStrength;
    vec2 totalDistortion = distortion1 + distortion2;

    // Ahora podemos usar este valor para distorsionar las coordenadas de textura de reflexion y refraccion
    refractTexCoords += totalDistortion;

    /* Debido a la textura proyectiva, las coordenadas de textura de reflexion y refraccion en la parte inferior de la
     * pantalla, tendran un valor [y] de casi cero y debido a que la distorsion agrega un offset a las coordenadas de
     * textura, a veces van a estar por debajo de cero. Esto hace que las texturas se salgan de la parte inferior de la
     * textura y luego regresen redondeadas hasta la parte superior de la textura debido a la forma en que OpenGL tiene
     * los tiles. Para solucionar este problema, se fijan las coordenadas de la textura para asegurarnos de que nunca
     * suban ni bajen demasiado. Esto se hace desde el metodo clamp para sujetar las coordenadas de textura de refraccion
     * y reflexion entre los valores 0.001 y 0.999. */
     refractTexCoords = clamp(refractTexCoords, 0.001, 0.999);

    reflectTexCoords += totalDistortion;
    /* En el caso de la reflexion, tenemos que fijar los componentes de forma separada. Para la coordenada [y], los
     * valores se invierten entre -0.999 y -0.001. */
    reflectTexCoords.x = clamp(reflectTexCoords.x, 0.001, 0.999);
    reflectTexCoords.y = clamp(reflectTexCoords.y, -0.999, -0.001);

    /* Para distorsionar una textura, podemos agregar un desplazamiento a las coordenadas de texturas usando un vector
     * como vec2(-0.1, 0.0), en donde desplaza el reflejo hacia la derecha. Pero esto solo agrega una distorcion constante
     * en todo el quad del agua. Para que esto parezca realista, la distorcion debe ser distinta en diferentes puntos
     * de la superficie del agua. Por lo que necesitamos que este valor de distorcion sea diferente para diferentes
     * lugares del quad. Y aqui es donde entra en juego el DuDv Map. Un DuDv Map es solo una textura simple con muchas
     * oscilaciones rojas y verdes. Esta textura esta llena de muchos colores rojo y verde, y estos valores de rojo y
     * verde son todos vectores 2D que podemos usar como desplazamientos para agregar a las coordenadas de textura de
     * reflexion y refraccion. Los valores rojo y verde siempre son positivos en la textura DuDv, obviamente no puede
     * tener un color negativo, por lo que nuestras distorciones siempre seran positivas. Para tener distorciones tanto
     * positivas como negativas para que parezca realista, necesitamos convertir los valores rojo y verde del mapa DuDv
     * antes de usarlo. Los valores de color estan todos entre 0 y 1, asi que para convertirlos entre -1 y 1
     * multiplicamos x2 y restamos 1. */
    vec4 reflectColour = texture(reflectionTexture, reflectTexCoords);
    vec4 refractColour = texture(refractionTexture, refractTexCoords);

	out_Color = mix(reflectColour, refractColour, 0.5);

    // Representa un color azul verdoso semitransparente en el espacio de color RGBA
    vec4 color = vec4(0.0, 0.3, 0.5, 1.0);
	float mezcla = 0.2; // 20% mezcla
	// Mezcla el color final con el color azul verdoso en un 20%
	out_Color = mix(out_Color, color, mezcla);

}