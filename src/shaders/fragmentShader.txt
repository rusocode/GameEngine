#version 400 core

// La entrada al fragmentShader es la salida del vertexShader
in vec2 pass_textureCoords;
in vec3 surfaceNormal;
in vec3 toLightVector;
in vec3 toCameraVector;

uniform sampler2D textureSampler;
uniform vec3 lightColour;
uniform float shineDamper;
uniform float reflectivity;

// La salida es el color del pixel que esta procesando actualmente y que sera un vector de 4 colores con su respectiva luz y luz especular
out vec4 out_Color;

void main(void) {

    /* Normaliza los dos vectores para asegurarse de que el tamanio de los dos vectores sea uno. Asi la direccion del
     * vector permanece exactamente igual, de modo que solo importa la direccion y la magnitud del vector es irrelevante. */
    vec3 unitNormal = normalize(surfaceNormal);
    vec3 unitLightVector = normalize(toLightVector);

    // Calcula el producto escalar de los dos vectores normales. El resultado representa que tan correcto debe ser el pixel
    float nDotl = dot(unitNormal, unitLightVector);
    // Se asegura de que el resultado se encuentre entre 0 y 1, porque a veces el producto escalar devolvera valores menores a 0
    float brightness = max(nDotl, 0.0);
    // Multiplica el brillo por el color de la luz para obtener la iluminacion final
    vec3 diffuse = brightness * lightColour;

    // Normaliza el vector de la camara para asegurarnos que el tamanio de este sea solo 1
    vec3 unitVectorToCamera = normalize(toCameraVector);
    // Crea el vector con los puntos en la direccion de donde proviene la luz, esto es justo lo opuesto al vector que apunta hacia la luz, por lo tanto lo convierte a negativo
    vec3 lightDirection = -unitLightVector;
    // Esta funcion toma el vector de luz entrante y la normal de la superficie con la que desea reflejar la luz y devuele la luz reflejada
    vec3 reflectedLightDirection = reflect(lightDirection, unitNormal);

    // Indica que tan brillante debe ser la luz especular sin ninguna amortiguacion (shineDamper)
    float specularFactor = dot(reflectedLightDirection, unitVectorToCamera);
    // Se asegura de que el factor especular sea mayor que cero porque obviamente no podemos tener un brillo negativo
    specularFactor = max(specularFactor, 0.0);
    /* Aplica la amortiguacion elevando el factor especular a la potencia del valor de amortiguacion, lo que hace que
     * los factores especulares bajos sean aun mas bajos, pero no afecta tanto a los valores mas altos. */
    float dampedFactor = pow(specularFactor, shineDamper);
    // Multiplica el factor amortiguado por la reflectividad por el color de la luz que la luz especular sea el color de la fuente de luz
    vec3 finalSpecular = dampedFactor * reflectivity * lightColour;

    /* texture() es un metodo especial de GLSL que devuelve el color del pixel en la textura en esas coordenadas que le damos, de modo
     * que ese metodo muestreara la textura que le dimos en el textureSampler y la probara en esas coordenadas de
     * texturas que le dimos en pass_textureCoords, y obtendra el color del pixel que encuentre en esas coordenadas de
     * textura y lo que vamos a hacer con ese color es simplemente enviarlo al pixel que se esta procesando actualmente.
     * Por ultimo, el color de la textura se multiplica por la luz calculada.
     * El valor final de la luz especular (finalSpecular) se agrega a la iluminacion difusa convirtiendolo en un vector
     * 4D porque nuestro color es un vector 4D. */
    out_Color = vec4(diffuse, 1.0) * texture(textureSampler, pass_textureCoords) + vec4(finalSpecular, 1.0);
}